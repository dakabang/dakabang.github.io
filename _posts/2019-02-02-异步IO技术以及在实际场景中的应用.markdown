## 基本概念
异步IO是一个在平时工作中经常提出的一个概念，这个概念也有很多实际中的应用，首先说一下什么是异步IO，说白了就只是进行IO操作，但是不等待结果，结果等到IO完成了通知进程/线程继续往下执行。这样有什么好处呢？就是避免不必要的系统开销，如果我们完全使用同步IO，也不是不可以，很多对性能要求不高的场景下都是这么做的，但是在IO非常频繁的应用场景下，等待IO的操作会导致进程/线程挂起，而此时操作系统就要通过切换进程/线程来调度资源，这个调度的过程往往伴随着内存空间的切换，寄存器，CPU Cache的切换，造成很大的性能瓶颈。

## 异步IO的应用场景
在说明异步IO的实现方法之前，首要要弄懂什么情况下适合异步IO？
1. IO操作比较频繁，异步IO的优势在于等待IO的时间可以用来干其他事情，而我又不想这个线程阻塞在这里造成浪费，频繁的IO操作会造成这个等待非常多，无疑造成资源的浪费，因此很难发挥计算性能
2. 多线程程序，如果只是单线程的程序，并且IO等待是必须的（没有完成IO无法执行下一步）的情况下，无法做异步IO

## 异步IO的实现
异步IO最关键的一点就是，当我IO阻塞挂起之后，这个IO给谁处理？处理完又是谁来唤醒阻塞的线程？这个就要用到IO multiplexing（IO复用）了，multiplexing表示复用，是一个通信和计算机网络的属于，意思是在一个信道上传输多路信号的技术。IO复用也是这样，在同一个线程上完成多个IO的操作。

- 通过epoll,select,poll,kqueue等系统IO复用的机制来完成异步的IO调用，具体实现流程如下
	1. 申请epoll实例，开始轮训epoll，监听fd上的事件
	1. 应用程序请求IO操作
	2. 事件注册到epoll句柄上
	3. epoll轮训过程中了解到IO已经准备好，调用callback完成异步调用。

因此在写异步代码的时候经常有这样的操作
```
// 这一步操作只是把请求发出去，耗时很短
// 等到server把回包发回来之后，epoll机制会调用callback完成回包处理
client->request(req, callback);
```

但是这样的实现方式有一个开发中的弊端，就是逻辑分割比较严重，试想想，如果你的一个函数需要调用三个RPC服务，那么按照上面的方法就要写成这样
```
auto callback1 = {
	// 收到服务1的回包，处理之后再调用服务2
	....
	client->request(req2, callback2);
};
auto callback2 = {
	// 收到服务2的回包，处理之后再请求服务3
	...
	client->request(req3, callback3);
};
auto callback3 = {
	// 处理服务3的回包
};
client->request(req1, callback1);
```
如果遇到更多IO调用的情况就更加完蛋，这种异步编程模式的弊端（callback嵌套）也叫做***callback hell***，那么有什么方法可以避免这种蛋疼的编程模式的情况下性能仍然能够比较好吗？当然有，这就是协程。

## 协程的实现
协程听起来很玄乎，但是其实很容易理解，首先我们介绍一下为什么要协程，协程有啥好处。首先，协程能够满足异步IO的需求，不用在线程中等待IO结果，并且，协程能够使用同步的代码进行开发，这就非常有吸引力了，相当于既有异步模式的性能，又有同步模式的简单。不过，相比于纯异步IO模式，协程模式会有一些性能损失（协程创建，销毁，切换的成本），但是考虑到很多情况下性能瓶颈并不在此，因此得到了很多大厂的青睐。
下面说一下协程的原理，就是通过保存寄存器和调用栈的内容，来保存一个线程执行的快照(协程)，通过一个协程调度器完成协程之间的切换，这样说可能有点概括了，我们还是举一个例子，还是上面的例子，一个函数需要完成3个RPC调用，协程的方式怎么做呢？

1. 创建3个协程对象，分别传入函数地址和入参格式
2. 调用第一个协程（即调用服务1），这时候因为写的是同步代码，按道理应该卡在这里等待IO，但是协程调度器会直接挂起这个协程，让出CPU，挂起协程的过程就是前面说的，保存现场（寄存器和调用栈）
3. 等到IO准备好了（依然是epoll来完成通知），就恢复这个协程对象，从刚才执行完成的地方继续执行。

是不是很神奇，这样开发者就不用关心异步逻辑如何分割的问题，直接按照同步的方式写代码，框架会take care of everything！
协程中保存和恢复上下文可以通过glibc的ucontext或者直接通过汇编来实现（具体实现过程会在下一篇博客中具体说明）
协程等待IO的时候不等待而是挂起，让出CPU，这个操作是通过hook的方式将系统调用read，write等等重写，因此开发者还是直接调用read,write，但是其内部逻辑已经是覆盖后协程的处理逻辑。
